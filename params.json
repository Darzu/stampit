{"name":"Stampit","tagline":"Create objects from reusable, composable behaviors.","body":"# Stampit\r\n\r\nCreate objects from reusable, composable behaviors.\r\n\r\n## Features\r\n\r\n * Create functions (called factories) which stamp out new objects. All of the new objects inherit all of the prescribed behavior.\r\n\r\n * Compose factories together to create new factories.\r\n\r\n * Inherit methods and default state.\r\n \r\n * Supports composable private state and privileged methods.\r\n \r\n * State is cloned for each instance, so it won't be accidentally shared.\r\n \r\n * For the curious - it's great for learning about prototypal OO. It mixes three major types of prototypes:\r\n   1. differential inheritance, aka delegation (for methods),\r\n   2. cloning, aka concatenation/exemplar prototypes (for state),\r\n   3. functional / closure prototypes (for privacy / encapsulation)\r\n\r\n## What's the Point?\r\n\r\nPrototypal OO is great, and JavaScript's capabilities give us some really powerful tools to explore it, but it could be easier to use.\r\n\r\nBasic questions like \"how do I inherit privileged methods and private data?\" and \"what are some good alternatives to inheritance hierarchies?\" are stumpers for many JavaScript users.\r\n\r\nLet's answer both of these questions at the same time. First, we'll use a closure to create data privacy:\r\n\r\n```\r\nvar a = stampit().enclose(function () {\r\n  var a = 'a';\r\n  this.getA = function () {\r\n    return a;\r\n  };\r\n});\r\n```\r\n\r\nIt uses function scope to encapsulate private data. Note that the getter must be defined inside the function in order to access the closure variables.\r\n\r\nLet's see if that worked:\r\n\r\n```\r\na(); // Object -- so far so good.\r\na().getA(); // \"a\"\r\n```\r\n\r\nYes. Got it. In both of these instances, we actually created a brand new object, and then immediately threw it away, because we didn't assign it to anything. Don't worry about that.\r\n\r\nHere's another:\r\n\r\n```\r\nvar b = stampit().enclose(function () {\r\n  var a = 'b';\r\n  this.getB = function () {\r\n    return a;\r\n  };\r\n});\r\n```\r\n\r\nThose `a`'s are not a typo. The point is to demonstrate that `a` and `b`'s private variables won't clash.\r\n\r\nBut here's the real treat:\r\n\r\n```\r\nvar c = stampit.compose(a, b);\r\n\r\nvar foo = c(); // we won't throw this one away...\r\n\r\nfoo.getA(); // \"a\"\r\nfoo.getB(); // \"b\"\r\n```\r\n\r\nWAT? Yeah. You just inherited privileged methods and private data from two sources at the same time.\r\n\r\nBut that's boring. Let's see what else is on tap:\r\n\r\n```\r\n// Some more privileged methods, with some private data.\r\n// Use stampit.extend() to make this feel declarative:\r\nvar availability = stampit({}, {}, function () {\r\n  var isOpen = false; // private\r\n\r\n  reSurn stampit.extend(this, {\r\n    open: function open() {\r\n      isOpen = true;\r\n      return this;\r\n    },\r\n    close: function close() {\r\n      isOpen = false;\r\n      return this;\r\n    },\r\n    isOpen: function isOpenMethod() {\r\n      return isOpen;\r\n    }\r\n  });\r\n});\r\n\r\n// Here's a mixin with public methods, and some state:\r\nvar membership = stampit({\r\n    add: function (member) {\r\n      this.members[member.name] = member;\r\n      return this;\r\n    },\r\n    getMember: function (name) {\r\n      return this.members[name];\r\n    }\r\n  },\r\n  {\r\n    members: {}\r\n  });\r\n\r\n// Let's set some defaults: \r\nvar defaults = stampit({}, {\r\n        name: 'The Saloon',\r\n        specials: 'Whisky, Gin, Tequila'\r\n      });\r\n\r\n// Classical inheritance has nothing on this. No parent/child coupling. No deep inheritance hierarchies.\r\n// Just good, clean code reusability.\r\nvar bar = stampit.compose(defaults, availability, membership);\r\n\r\n// Note that you can override state on instantiation:\r\nvar myBar = bar({name: 'Moe\\'s'});\r\n\r\n// Silly, but proves that everything is as it should be.\r\nmyBar.add({name: 'Homer' }).open().getMember('Homer'); \r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}